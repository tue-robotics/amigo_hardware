########################################################################
#                                                                      #
# Spindle Controller deployer file. deployer file.                	   #
#                                                                      #
# Generic Structure	by Max Baeten				                       #
# September 2011                                                       #
#                                                                      #
########################################################################

#### IMPORT PACKAGE ####
# To be able to load components from this package and all packages in the manifest
import("amigo_spindle_controller")
trigger
Supervisor.NameBodyPart( 2, "spindle")

#### DECLARATION OF PARAMETERS ####
var double Ts = 0.001
var strings JOINT_NAMES = strings( "torso_joint" )

### Loading Components ###
#Reading Encoders
loadComponent("SPINDLE_ReadEncoders","SOEM::ReadEncoders")
addPeer("Supervisor","SPINDLE_ReadEncoders")
SPINDLE_ReadEncoders.setPeriod(Ts)
SPINDLE_ReadEncoders.encoderbits = 65536
SPINDLE_ReadEncoders.enc2SI = array (-4.1666667e-7); # Minus because spindle up is defined positive.
SPINDLE_ReadEncoders.configure

#Publish component
#loadComponent("SpindlePositionToROS","ROS::DoublesToROS")
#addPeer("Supervisor","SpindlePositionToROS")
#setActivity("SpindlePositionToROS",0.01,LowestPriority,ORO_SCHED_OTHER)
#SpindlePositionToROS.NumberOfDoublesInVector = 1
#SpindlePositionToROS.configure

# Publish JointState Component
loadComponent("SpindleWriteJointStates","ROS::DoublesToJointState")
addPeer("Supervisor","SpindleWriteJointStates")
setActivity("SpindleWriteJointStates",0.05,HighestPriority,ORO_SCHED_RT)
SpindleWriteJointStates.JointNames = strings ( "torso_joint" )
SpindleWriteJointStates.configure

# Select either the old (for amigo_msgs) and new (for jointstate messages) interface
#Reading spindle setpoints (old)
#loadComponent("Spindle_ReadReferences","SPINDLE::ReadSpindleSetpoint")
#Reading spindle setpoints (new)
loadComponent("Spindle_ReadReferences","SPINDLE::ReadSpindleSetpointJointState") ;# if you rename this component also rename in spindle homing component
addPeer("Supervisor","Spindle_ReadReferences")
Spindle_ReadReferences.min_pos = 0.075
Spindle_ReadReferences.max_pos = 0.4
Spindle_ReadReferences.max_vel = 0.07
Spindle_ReadReferences.configure

### Read reference joint angles using Jointstate messages###
# Won't work in the current structure #
#loadComponent("SpindleReadReferenceJointStates","ROS::JointStateToDoubles")
#setActivity("SpindleReadReferenceJointStates",0.0,HighestPriority,ORO_SCHED_RT)
#SpindleReadReferenceJointStates.NumberOfJoints = 1
#SpindleReadReferenceJointStates.configure

#Loading Reference Generator
loadComponent("SpindleReferenceGenerator","ReferenceGenerator")
addPeer("Supervisor","SpindleReferenceGenerator")
SpindleReferenceGenerator.setPeriod(Ts)
SpindleReferenceGenerator.NrInterpolators = 1
SpindleReferenceGenerator.InterpolatorDt = Ts
SpindleReferenceGenerator.InterpolatorEps = 1.0
SpindleReferenceGenerator.configure
#SpindleReferenceGenerator.interpolator1 = array (0.0, 0.07, 0.1);
SpindleReferenceGenerator.interpolator1 = array (0.0, 0.07, 0.03); #Velocity is carefully tuned. Do not increase because integrator will fill!

#Loading Homing component
loadComponent("Spindle_Homing","SpindleHoming")
connectPeers("Supervisor","Spindle_Homing")
connectPeers("Spindle_Homing","Supervisor")
connectPeers("Spindle_Homing","SPINDLE_ReadEncoders")
addPeer("Spindle_Homing","SpindleReferenceGenerator")
addPeer("Spindle_Homing","Spindle_ReadReferences")
Spindle_Homing.home_vel = 0.01
Spindle_Homing.home_acc = 0.1; #Fast acc means constant velocity means better reproducing homing
Spindle_Homing.stroke  = 0.41
Spindle_Homing.endpos = 0.35
Spindle_Homing.homed = 0; # =False
Spindle_Homing.configure

#Loading Homing component
#loadComponent("Spindle_Homing","AMIGO::Homing")
#connectPeers("Supervisor","Spindle_Homing")
#connectPeers("Spindle_Homing","Supervisor")
#connectPeers("Spindle_Homing","SPINDLE_ReadEncoders")
#addPeer("Spindle_Homing","SpindleReferenceGenerator")
#addPeer("Spindle_Homing","Spindle_ReadReferences")
#Spindle_Homing.homing_body   		= "Spindle" 			;# name of the body that is stopped/started during homing procedure
#Spindle_Homing.require_homing   	= true		 			;# require homing
#Spindle_Homing.homing_type			= array (3.0)			;# 0 = abs sen homing 1 = servo error homing  2 = Force sen homing  3 = endSwitch homing
#Spindle_Homing.homing_order			= array (1.0)			;# Order in which the joints are homed providing (2.0 3.0 1.0) will home joint two, then joint three and at last joint one
#Spindle_Homing.homing_refPos		= array (1.0)   		;# Pos Reference for the homing joint
#Spindle_Homing.homing_refVel		= array (0.01)  		;# Vel Reference for the homing joint
#Spindle_Homing.homing_stroke		= array (0.41)			;# Stroke from zero point to homing point (encoders are resetted using this value)
#Spindle_Homing.homing_midpos		= array (0.35)  		;# position that the body should have during homing. To avoid collisions with other bodies/ itself
#Spindle_Homing.homing_endpos		= array (0.35)			;# position that the body should go to after homing is finished. (could be same as midpos)
#connect ("DigitalIns2.out2", "Spindle_Homing.endswitch", ConnPolicy() )
#connect ("SPINDLE_ReadEncoders.out", "Spindle_Homing.relPos_in", ConnPolicy() )
#connect ("Spindle_Homing.ref_out","SpindleReferenceGenerator.refin", ConnPolicy() )
#Spindle_Homing.configure

#Calculating Errors
loadComponent("SPINDLE_ComputeError","MATH::Subtraction")
addPeer("Supervisor","SPINDLE_ComputeError")
SPINDLE_ComputeError.vectorsize = 1
SPINDLE_ComputeError.configure

#Loading controller components
#Gain
loadComponent("SpindleGain","MATH::Gain")
addPeer("Supervisor","SpindleGain")
SpindleGain.vectorsize = 1
SpindleGain.gain = -40; ###TODO: Move negative sign to AnalogOuts
SpindleGain.configure

#Integrator
loadComponent("SpindleIntegrator","FILTERS::WeakIntegrators")
addPeer("Supervisor","SpindleIntegrator")
SpindleIntegrator.zero_frequency = array ( 0.3 )
SpindleIntegrator.vector_size = 1
SpindleIntegrator.sampling_time = Ts
SpindleIntegrator.configure

#LeadLag
loadComponent("SpindleLeadLag","FILTERS::LeadLag")
addPeer("Supervisor","SpindleLeadLag")
SpindleLeadLag.vector_size = 1
SpindleLeadLag.sampling_time = Ts
SpindleLeadLag.zero_frequency = array (1.6)
SpindleLeadLag.pole_frequency = array (60.0)
SpindleLeadLag.configure

#LowPass
loadComponent("SpindleSecondOrderLowPass","FILTERS::SecondOrderLowPass")
addPeer("Supervisor","SpindleSecondOrderLowPass")
SpindleSecondOrderLowPass.vector_size = 1
SpindleSecondOrderLowPass.sampling_time = Ts
SpindleSecondOrderLowPass.pole_frequency = array (20.0)
SpindleSecondOrderLowPass.pole_damping = array (0.7)
SpindleSecondOrderLowPass.configure

#Calculating Feed Forward
loadComponent("SpindleCalculateFFW","CalculateFFW")
addPeer("Supervisor","SpindleCalculateFFW")
SpindleCalculateFFW.FFWgrav = 0.07
SpindleCalculateFFW.FFWstat = 0.05
SpindleCalculateFFW.FFWdyn = 0.4
SpindleCalculateFFW.FFWacc = 0.3
#SpindleCalculateFFW.FFWgrav = 0.0
#SpindleCalculateFFW.FFWstat = 0.0
#SpindleCalculateFFW.FFWdyn = 0.0
#SpindleCalculateFFW.FFWacc = 0.0
SpindleCalculateFFW.configure

#Calculating Output to encoders
loadComponent("SpindleAddFeedForward","MATH::Addition")
addPeer("Supervisor","SpindleAddFeedForward")
SpindleAddFeedForward.vectorsize = 1
SpindleAddFeedForward.configure

#TODO: Should be passive, only acting on actual errors
#Loading Safety component
loadComponent("SpindleSafety","SpindleSafety")
addPeer("Supervisor","SpindleSafety")
SpindleSafety.error_margin = 0.05
SpindleSafety.configure
# Brake and amplifier should be switched simultaneously: it is undesired to either power the motor with the brake on or to have no power with the brake off

#### LOAD COMPONENT TO PUBLISH STATUS ###
loadComponent("SpindleStatus","ROS::BoolToROS")
addPeer("Supervisor","SpindleStatus")
SpindleStatus.NumberOfBoolPorts = 1
SpindleStatus.configure
SpindleStatus.setPeriod(1)

#### LOAD COMPONENT TO PUBLISH DIAGNOSTICS ###
loadComponent("SpindleDiagnostics","ROS::RosDiagnostics")
addPeer("Supervisor","SpindleDiagnostics")
SpindleDiagnostics.statusname = "SpindleController"
SpindleDiagnostics.NumberOfVectorPorts = 4
SpindleDiagnostics.NumberOfBoolPorts = 1
SpindleDiagnostics.configure
setActivity("SpindleDiagnostics",1.0,LowestPriority,ORO_SCHED_OTHER)
SpindleDiagnostics.vecname1 = "Reference"
SpindleDiagnostics.vecname2 = "Error"
SpindleDiagnostics.vecname3 = "Voltage"
SpindleDiagnostics.vecname4 = "ControlEffort"
SpindleDiagnostics.boolname1 = "Safe"

#### LOAD COMPONENT TO SET UP TRACING ###
#var ConnPolicy tracingpolicy;	tracingpolicy.type = BUFFER; 	tracingpolicy.size = 2*65536;	tracingpolicy.lock_policy = LOCKED
#loadComponent("SPINDLE_Tracing","Signal::Tracing")
#addPeer("Supervisor","SPINDLE_Tracing")
#setActivity("SPINDLE_Tracing",0.0,HighestPriority,ORO_SCHED_RT)
#SPINDLE_Tracing.vector_sizes = array (1.0 , 1.0 , 1.0 , 1.0, 1.0 )
#SPINDLE_Tracing.buffersize = 2*65536;
#SPINDLE_Tracing.filename = "/home/amigo/ros/fuerte/tue/user/Teun/Log/spindle_15_10_13.dat"
#SPINDLE_Tracing.Ts = Ts
#SPINDLE_Tracing.Crash_if_done = 1; #If 1 the controllers are terminated after gathering data
#SPINDLE_Tracing.configure
#connect ("SpindleReferenceGenerator.posout","SPINDLE_Tracing.in1", tracingpolicy );		# reference after reference generator
#connect ("SPINDLE_ComputeError.out","SPINDLE_Tracing.in2", tracingpolicy ) ; 			# error
#connect ("SpindleAddFeedForward.out","SPINDLE_Tracing.in3", tracingpolicy ) ; 			# control effort feedback plus feedforward
#connect ("SpindleSecondOrderLowPass.out","SPINDLE_Tracing.in4", tracingpolicy ) ; 		# control effort only feedback
#connect ("SpindleCalculateFFW.FFW_out","SPINDLE_Tracing.in5", tracingpolicy ) ; 		# control effort only feedforward

#### SETTING UP JOINTSTATE AGGREGATOR ####
JointStateAggregator.addJointNames(JOINT_NAMES)
JointStateAggregator.addAggregationPort("torso")

#### CONNECT COMPONENTS ####
connect ("Soem.Slave_1006.Slave_1006_value","SPINDLE_ReadEncoders.enc1_in", ConnPolicy() )
#connect ("SPINDLE_ReadEncoders.out","SpindlePositionToROS.in", ConnPolicy() )
connect( "SPINDLE_ReadEncoders.out", "SpindleWriteJointStates.pos_in", ConnPolicy() )
connect ("SpindleWriteJointStates.out", "JointStateAggregator.torso", ConnPolicy() )
connect ("Spindle_ReadReferences.out","SpindleReferenceGenerator.refin", ConnPolicy() )
connect ("SPINDLE_ReadEncoders.out","SpindleReferenceGenerator.actual_pos", ConnPolicy() )
connect ("DigitalIns2.out2", "Spindle_Homing.endswitch", ConnPolicy() )
connect ("Spindle_Homing.ref_out","SpindleReferenceGenerator.refin", ConnPolicy() )
connect ("SpindleReferenceGenerator.posout","SPINDLE_ComputeError.in_plus", ConnPolicy() )
connect ("SPINDLE_ReadEncoders.out","SPINDLE_ComputeError.in_minus", ConnPolicy() )
connect ("SPINDLE_ComputeError.out","SpindleGain.in", ConnPolicy() )
connect ("SpindleGain.out","SpindleIntegrator.in", ConnPolicy() )
connect ("SpindleIntegrator.out","SpindleLeadLag.in", ConnPolicy() )
connect ("SpindleLeadLag.out","SpindleSecondOrderLowPass.in", ConnPolicy() )
connect ("SpindleReferenceGenerator.velout","SpindleCalculateFFW.ref_vel", ConnPolicy() )
connect ("SpindleReferenceGenerator.accout","SpindleCalculateFFW.ref_acc", ConnPolicy() )
connect ("SpindleCalculateFFW.FFW_out","SpindleAddFeedForward.in1", ConnPolicy() )
connect ("SpindleSecondOrderLowPass.out","SpindleAddFeedForward.in2_event", ConnPolicy() )
connect ("SpindleAddFeedForward.out","AnalogOuts.spindle", ConnPolicy() )
connect ("SpindleSafety.spindle_brake","DigitalOuts.in3", ConnPolicy() );   # Spindle brake
connect ("SpindleSafety.spindle_brake","DigitalOuts2.in1", ConnPolicy() );	# Spindle amplifier
connect ("SPINDLE_ComputeError.out","SpindleSafety.error_pos", ConnPolicy() )
connect ("SpindleSafety.spindle_brake", "SpindleStatus.bool_in1", ConnPolicy() )
connect ("SpindleReferenceGenerator.posout", "SpindleDiagnostics.vec1", ConnPolicy() )
connect ("SPINDLE_ComputeError.out", "SpindleDiagnostics.vec2", ConnPolicy() )
connect ("SpindleAddFeedForward.out", "SpindleDiagnostics.vec3", ConnPolicy() )
connect ("SpindleSecondOrderLowPass.out", "SpindleDiagnostics.vec4", ConnPolicy() )
connect ("SpindleSafety.safety", "SpindleDiagnostics.bool1", ConnPolicy() )

#### CONNECT ROS STREAMS ####
stream( "Supervisor.spindle_fireup", ros.topic("/spindle_fireup"))
stream( "Supervisor.spindle_enabled", ros.topic("/spindle_enabled"))

stream("Spindle_ReadReferences.spindle_setpoint", ros.topic("/amigo/torso/references"));
stream("SpindleStatus.bool_out1", ros.topic("/spindle_status"));
stream("SpindleDiagnostics.diagnostics", ros.topic("/diagnostics"));
stream( "SpindleWriteJointStates.out", ros.topic("/amigo/torso/measurements"))
#stream( "SpindleWriteJointStates.out", ros.topic("/amigo/joint_states"))
#stream("SpindlePositionToROS.out1", ros.topic("/spindle_position"))


#### START COMPONENTS ####
Supervisor.AddAllwaysOnPeer ("SPINDLE_ReadEncoders")
#Supervisor.AddAllwaysOnPeer ("SpindlePositionToROS")
Supervisor.AddAllwaysOnPeer ("SpindleWriteJointStates")
Supervisor.AddAllwaysOnPeer ("SpindleDiagnostics")
Supervisor.AddAllwaysOnPeer ("SpindleStatus")

Supervisor.AddPeerToBodyPart ("Spindle_ReadReferences",2 )
Supervisor.AddPeerToBodyPart ("SpindleReferenceGenerator",2 )
Supervisor.AddPeerToBodyPart ("SPINDLE_ComputeError",2 )
Supervisor.AddPeerToBodyPart ("SpindleGain",2 )
Supervisor.AddPeerToBodyPart ("SpindleIntegrator",2 )
Supervisor.AddPeerToBodyPart ("SpindleLeadLag",2 )
Supervisor.AddPeerToBodyPart ("SpindleSecondOrderLowPass",2 )
Supervisor.AddPeerToBodyPart ("SpindleCalculateFFW",2 )
Supervisor.AddPeerToBodyPart ("SpindleAddFeedForward",2 )
Supervisor.AddPeerToBodyPart ("SpindleSafety",2 )

Supervisor.AddAllwaysOnPeer ("Spindle_Homing"); #Homing stops itself after finishing, last component because all others have to be started in order to be stopped ;)
#Supervisor.AddAllwaysOnPeer ("SPINDLE_Tracing")
