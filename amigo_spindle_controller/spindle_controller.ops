########################################################################
#                                                                      #
# Spindle Controller deployer file. deployer file.                	   #
#                                                                      #
# Generic Structure	by Max Baeten				                       #
# September 2011                                                       #
#                                                                      #
########################################################################

#### IMPORT PACKAGE ####
# To be able to load components from this package and all packages in the manifest
import("amigo_spindle_controller")
trigger
Supervisor.NameBodyPart( 2, "spindle", true)


#### DECLARATION OF PARAMETERS ####
var double Ts = 0.001
var strings JOINT_NAMES = strings( "torso_joint" )

### Loading Components ###
#Reading Encoders
loadComponent("SPINDLE_ReadEncoders","SOEM::ReadEncoders")
addPeer("Supervisor","SPINDLE_ReadEncoders")
SPINDLE_ReadEncoders.setPeriod(Ts)
SPINDLE_ReadEncoders.encoderbits = 65536
SPINDLE_ReadEncoders.enc2SI = array (-4.1666667e-7); # Minus because spindle up is defined positive.
SPINDLE_ReadEncoders.configure

#Publish component
#loadComponent("SPINDLE_PositionToROS","ROS::DoublesToROS")
#addPeer("Supervisor","SPINDLE_PositionToROS")
#setActivity("SPINDLE_PositionToROS",0.01,LowestPriority,ORO_SCHED_OTHER)
#SPINDLE_PositionToROS.NumberOfDoublesInVector = 1
#SPINDLE_PositionToROS.configure

# Publish JointState Component
loadComponent("SPINDLE_WriteJointStates","ROS::DoublesToJointState")
addPeer("Supervisor","SPINDLE_WriteJointStates")
setActivity("SPINDLE_WriteJointStates",0.05,HighestPriority,ORO_SCHED_RT)
SPINDLE_WriteJointStates.JointNames = strings ( "torso_joint" )
SPINDLE_WriteJointStates.configure

# Select either the old (for amigo_msgs) and new (for jointstate messages) interface
#Reading spindle setpoints (old)
#loadComponent("SPINDLE_ReadReferences","SPINDLE::ReadSpindleSetpoint")
#Reading spindle setpoints (new)
loadComponent("SPINDLE_ReadReferences","SPINDLE::ReadSpindleSetpointJointState") ;# if you rename this component also rename in spindle homing component
addPeer("Supervisor","SPINDLE_ReadReferences")
SPINDLE_ReadReferences.min_pos = 0.075
SPINDLE_ReadReferences.max_pos = 0.4
SPINDLE_ReadReferences.max_vel = 0.07
SPINDLE_ReadReferences.configure

### Read reference joint angles using Jointstate messages###
# Won't work in the current structure #
#loadComponent("SpindleReadReferenceJointStates","ROS::JointStateToDoubles")
#setActivity("SpindleReadReferenceJointStates",0.0,HighestPriority,ORO_SCHED_RT)
#SpindleReadReferenceJointStates.NumberOfJoints = 1
#SpindleReadReferenceJointStates.configure

#Loading Reference Generator
loadComponent("SPINDLE_ReferenceGenerator","ReferenceGenerator")
addPeer("Supervisor","SPINDLE_ReferenceGenerator")
SPINDLE_ReferenceGenerator.setPeriod(Ts)
SPINDLE_ReferenceGenerator.NrInterpolators = 1
SPINDLE_ReferenceGenerator.InterpolatorDt = Ts
SPINDLE_ReferenceGenerator.InterpolatorEps = 1.0
SPINDLE_ReferenceGenerator.configure
#SPINDLE_ReferenceGenerator.interpolator1 = array (0.0, 0.07, 0.03);
SPINDLE_ReferenceGenerator.interpolator1 = array (0.0, 0.07, 0.1); #Velocity is carefully tuned. Do not increase because integrator will fill!

#Calculating Errors
loadComponent("SPINDLE_ComputeError","MATH::Subtraction")
addPeer("Supervisor","SPINDLE_ComputeError")
SPINDLE_ComputeError.vectorsize = 1
SPINDLE_ComputeError.configure

#Loading Homing component
loadComponent("SPINDLE_Homing","SpindleHoming")
connectPeers("Supervisor","SPINDLE_Homing")
connectPeers("SPINDLE_Homing","Supervisor")
connectPeers("SPINDLE_Homing","SPINDLE_ReadEncoders")
addPeer("SPINDLE_Homing","SPINDLE_ReferenceGenerator")
addPeer("SPINDLE_Homing","SPINDLE_ReadReferences")
SPINDLE_Homing.home_vel = 0.01
SPINDLE_Homing.home_acc = 0.1; #Fast acc means constant velocity means better reproducing homing
SPINDLE_Homing.stroke  = 0.41
SPINDLE_Homing.endpos = 0.35
SPINDLE_Homing.homed = 0; # =False
SPINDLE_Homing.configure
connect ("DigitalIns2.out2", "SPINDLE_Homing.endswitch", ConnPolicy() )
connect ("SPINDLE_Homing.ref_out","SPINDLE_ReferenceGenerator.refin", ConnPolicy() )

#Loading Homing component
#loadComponent("SPINDLE_Homing","SUPERVISORY::Homing")
#connectPeers("Supervisor","SPINDLE_Homing")
#connectPeers("SPINDLE_Homing","Supervisor")
#connectPeers("SPINDLE_Homing","SPINDLE_ReadEncoders")
#addPeer("SPINDLE_Homing","SPINDLE_ComputeError")
#addPeer("SPINDLE_Homing","SPINDLE_ReadReferences")
#addPeer("SPINDLE_Homing","SPINDLE_ReferenceGenerator")
#SPINDLE_Homing.homing_body   		= "spindle" 			;# name of the body that is stopped/started during homing procedure
#SPINDLE_Homing.homing_compname		= "SPINDLE" 			;# orocos prefix
#SPINDLE_Homing.require_homing   	= true		 			;# require homing
#SPINDLE_Homing.homing_type			= array (3.0)			;# 0 = abs sen homing 1 = servo error homing  2 = Force sen homing  3 = endSwitch homing
#SPINDLE_Homing.homing_order			= array (1.0)			;# Order in which the joints are homed providing (2.0 3.0 1.0) will home joint two, then joint three and at last joint one
#SPINDLE_Homing.homing_refPos		= array (1.0)   		;# Pos Reference for the homing joint
#SPINDLE_Homing.homing_refVel		= array (0.01)  		;# Vel Reference for the homing joint
#SPINDLE_Homing.homing_stroke		= array (0.41)			;# Stroke from zero point to homing point (encoders are resetted using this value)
#SPINDLE_Homing.homing_midpos		= array (0.35)  		;# position that the body should have during homing. To avoid collisions with other bodies/ itself
#SPINDLE_Homing.homing_endpos		= array (0.35)			;# position that the body should go to after homing is finished. (could be same as midpos)
#SPINDLE_Homing.fast_step			= 0.025*Ts
#SPINDLE_Homing.slow_step			= 0.005*Ts
#SPINDLE_Homing.configure

### GAIN ###
loadComponent("SPINDLE_Gain","MATH::Gain")
addPeer("Supervisor","SPINDLE_Gain")
SPINDLE_Gain.vectorsize = 1
SPINDLE_Gain.gain = -40; ###TODO: Move negative sign to AnalogOuts
SPINDLE_Gain.configure

### INTEGRATOR ###
loadComponent("SPINDLE_Integrator","FILTERS::WeakIntegrators")
addPeer("Supervisor","SPINDLE_Integrator")
SPINDLE_Integrator.zero_frequency = array ( 0.3 )
SPINDLE_Integrator.vector_size = 1
SPINDLE_Integrator.sampling_time = Ts
SPINDLE_Integrator.configure

### LEADLAG ###
loadComponent("SPINDLE_LeadLag","FILTERS::LeadLag")
addPeer("Supervisor","SPINDLE_LeadLag")
SPINDLE_LeadLag.vector_size = 1
SPINDLE_LeadLag.sampling_time = Ts
SPINDLE_LeadLag.zero_frequency = array (1.6)
SPINDLE_LeadLag.pole_frequency = array (60.0)
SPINDLE_LeadLag.configure

### LOWPASS ###
loadComponent("SPINDLE_LowPass","FILTERS::SecondOrderLowPass")
addPeer("Supervisor","SPINDLE_LowPass")
SPINDLE_LowPass.vector_size = 1
SPINDLE_LowPass.sampling_time = Ts
SPINDLE_LowPass.pole_frequency = array (20.0)
SPINDLE_LowPass.pole_damping = array (0.7)
SPINDLE_LowPass.configure

#Calculating Feed Forward
loadComponent("SPINDLE_FFW","CalculateFFW")
addPeer("Supervisor","SPINDLE_FFW")
SPINDLE_FFW.FFWgrav = 0.07
SPINDLE_FFW.FFWstat = 0.05
SPINDLE_FFW.FFWdyn = 0.4
SPINDLE_FFW.FFWacc = 0.3
SPINDLE_FFW.configure

#Calculating Output to encoders
loadComponent("SPINDLE_Addition","MATH::Addition")
addPeer("Supervisor","SPINDLE_Addition")
SPINDLE_Addition.vectorsize = 1
SPINDLE_Addition.configure

#TODO: Should be passive, only acting on actual errors
#Loading Safety component
loadComponent("SPINDLE_Safety","SpindleSafety")
addPeer("Supervisor","SPINDLE_Safety")
SPINDLE_Safety.error_margin = 0.05
SPINDLE_Safety.configure
# Brake and amplifier should be switched simultaneously: it is undesired to either power the motor with the brake on or to have no power with the brake off

#### LOAD COMPONENT TO PUBLISH STATUS ###
#loadComponent("SPINDLE_Status","ROS::BoolToROS")
#addPeer("Supervisor","SPINDLE_Status")
#SPINDLE_Status.NumberOfBoolPorts = 1
#SPINDLE_Status.configure
#SPINDLE_Status.setPeriod(1)

#### LOAD COMPONENT TO PUBLISH DIAGNOSTICS ###
loadComponent("SPINDLE_Diagnostics","ROS::RosDiagnostics")
addPeer("Supervisor","SPINDLE_Diagnostics")
setActivity("SPINDLE_Diagnostics",1.0,LowestPriority,ORO_SCHED_OTHER)
SPINDLE_Diagnostics.statusname = "SpindleController"
SPINDLE_Diagnostics.NumberOfVectorPorts = 4
SPINDLE_Diagnostics.NumberOfBoolPorts = 1
SPINDLE_Diagnostics.configure
SPINDLE_Diagnostics.vecname1 = "Reference"
SPINDLE_Diagnostics.vecname2 = "Error"
SPINDLE_Diagnostics.vecname3 = "Voltage"
SPINDLE_Diagnostics.vecname4 = "ControlEffort"
SPINDLE_Diagnostics.boolname1 = "Safe"

#### LOAD COMPONENT TO SET UP TRACING ###
#var ConnPolicy tracingpolicy;	tracingpolicy.type = BUFFER; 	tracingpolicy.size = 2*65536;	tracingpolicy.lock_policy = LOCKED
#loadComponent("SPINDLE_Tracing","Signal::Tracing")
#addPeer("Supervisor","SPINDLE_Tracing")
#setActivity("SPINDLE_Tracing",0.0,HighestPriority,ORO_SCHED_RT)
#SPINDLE_Tracing.vector_sizes = array (1.0 , 1.0 , 1.0 , 1.0, 1.0 )
#SPINDLE_Tracing.buffersize = 2*65536;
#SPINDLE_Tracing.filename = "/home/amigo/ros/fuerte/tue/user/Teun/Log/spindle_15_10_13.dat"
#SPINDLE_Tracing.Ts = Ts
#SPINDLE_Tracing.Crash_if_done = 1; #If 1 the controllers are terminated after gathering data
#SPINDLE_Tracing.configure
#connect ("SPINDLE_ReferenceGenerator.posout","SPINDLE_Tracing.in1", tracingpolicy );		# reference after reference generator
#connect ("SPINDLE_ComputeError.out","SPINDLE_Tracing.in2", tracingpolicy ) ; 			# error
#connect ("SPINDLE_Addition.out","SPINDLE_Tracing.in3", tracingpolicy ) ; 			# control effort feedback plus feedforward
#connect ("SPINDLE_LowPass.out","SPINDLE_Tracing.in4", tracingpolicy ) ; 		# control effort only feedback
#connect ("SPINDLE_FFW.FFW_out","SPINDLE_Tracing.in5", tracingpolicy ) ; 		# control effort only feedforward

#### SETTING UP JOINTSTATE AGGREGATOR ####
JointStateAggregator.addJointNames(JOINT_NAMES)
JointStateAggregator.addAggregationPort("torso")

#connect ("DigitalIns2.out2", "SPINDLE_Homing.endswitch_in", ConnPolicy() )
#connect ("SPINDLE_ReadEncoders.out", "SPINDLE_Homing.relPos_in", ConnPolicy() )
#connect ("SPINDLE_Homing.ref_out","SPINDLE_ComputeError.in_plus", ConnPolicy() )



#### CONNECT COMPONENTS ####
connect ("Soem.Slave_1006.Slave_1006_value","SPINDLE_ReadEncoders.enc1_in", ConnPolicy() )
#connect ("SPINDLE_ReadEncoders.out","SPINDLE_PositionToROS.in", ConnPolicy() )
connect( "SPINDLE_ReadEncoders.out", "SPINDLE_WriteJointStates.pos_in", ConnPolicy() )
connect ("SPINDLE_WriteJointStates.out", "JointStateAggregator.torso", ConnPolicy() )
connect ("SPINDLE_ReadReferences.out","SPINDLE_ReferenceGenerator.refin", ConnPolicy() )
connect ("SPINDLE_ReadEncoders.out","SPINDLE_ReferenceGenerator.actual_pos", ConnPolicy() )
connect ("SPINDLE_ReferenceGenerator.posout","SPINDLE_ComputeError.in_plus", ConnPolicy() )
connect ("SPINDLE_ReadEncoders.out","SPINDLE_ComputeError.in_minus", ConnPolicy() )
connect ("SPINDLE_ComputeError.out","SPINDLE_Gain.in", ConnPolicy() )
connect ("SPINDLE_Gain.out","SPINDLE_Integrator.in", ConnPolicy() )
connect ("SPINDLE_Integrator.out","SPINDLE_LeadLag.in", ConnPolicy() )
connect ("SPINDLE_LeadLag.out","SPINDLE_LowPass.in", ConnPolicy() )
connect ("SPINDLE_ReferenceGenerator.velout","SPINDLE_FFW.ref_vel", ConnPolicy() )
connect ("SPINDLE_ReferenceGenerator.accout","SPINDLE_FFW.ref_acc", ConnPolicy() )
connect ("SPINDLE_FFW.FFW_out","SPINDLE_Addition.in1", ConnPolicy() )
connect ("SPINDLE_LowPass.out","SPINDLE_Addition.in2_event", ConnPolicy() )
connect ("SPINDLE_Addition.out","AnalogOuts.spindle", ConnPolicy() )
connect ("SPINDLE_Safety.spindle_brake","DigitalOuts.in3", ConnPolicy() );   # Spindle brake
connect ("SPINDLE_Safety.spindle_brake","DigitalOuts2.in1", ConnPolicy() );	# Spindle amplifier
connect ("SPINDLE_ComputeError.out","SPINDLE_Safety.error_pos", ConnPolicy() )
#connect ("SPINDLE_Safety.spindle_brake", "SPINDLE_Status.bool_in1", ConnPolicy() )

## Diagnostics ##
connect ("SPINDLE_ReferenceGenerator.posout", "SPINDLE_Diagnostics.vec1", ConnPolicy() )
connect ("SPINDLE_ComputeError.out", "SPINDLE_Diagnostics.vec2", ConnPolicy() )
connect ("SPINDLE_Addition.out", "SPINDLE_Diagnostics.vec3", ConnPolicy() )
connect ("SPINDLE_LowPass.out", "SPINDLE_Diagnostics.vec4", ConnPolicy() )
#connect ("SPINDLE_Safety.safety", "SPINDLE_Diagnostics.bool1", ConnPolicy() )

#### CONNECT ROS STREAMS ####
stream( "Supervisor.spindle_fireup", ros.topic("/spindle_fireup"))
stream( "Supervisor.spindle_enabled", ros.topic("/spindle_enabled"))

stream("SPINDLE_ReadReferences.spindle_setpoint", ros.topic("/amigo/torso/references"));
stream("SPINDLE_Safety.status", ros.topic("/spindle_status"));
stream("SPINDLE_Diagnostics.diagnostics", ros.topic("/diagnostics"));
stream( "SPINDLE_WriteJointStates.out", ros.topic("/amigo/torso/measurements"))
#stream( "SPINDLE_WriteJointStates.out", ros.topic("/amigo/joint_states"))
#stream("SPINDLE_PositionToROS.out1", ros.topic("/spindle_position"))

#### START COMPONENTS ####
Supervisor.AddAllwaysOnPeer ("SPINDLE_ReadEncoders")
#Supervisor.AddAllwaysOnPeer ("SPINDLE_PositionToROS")
Supervisor.AddAllwaysOnPeer ("SPINDLE_WriteJointStates")
Supervisor.AddAllwaysOnPeer ("SPINDLE_Diagnostics")
#Supervisor.AddAllwaysOnPeer ("SPINDLE_Status")

Supervisor.AddPeerToBodyPart ("SPINDLE_ReadReferences",2 )
Supervisor.AddPeerToBodyPart ("SPINDLE_ReferenceGenerator",2 )
Supervisor.AddPeerToBodyPart ("SPINDLE_ComputeError",2 )
Supervisor.AddPeerToBodyPart ("SPINDLE_Gain",2 )
Supervisor.AddPeerToBodyPart ("SPINDLE_Integrator",2 )
Supervisor.AddPeerToBodyPart ("SPINDLE_LeadLag",2 )
Supervisor.AddPeerToBodyPart ("SPINDLE_LowPass",2 )
Supervisor.AddPeerToBodyPart ("SPINDLE_FFW",2 )
Supervisor.AddPeerToBodyPart ("SPINDLE_Addition",2 )
Supervisor.AddPeerToBodyPart ("SPINDLE_Safety",2 )

Supervisor.AddAllwaysOnPeer ("SPINDLE_Homing"); #Homing stops itself after finishing, last component because all others have to be started in order to be stopped ;)
#Supervisor.AddAllwaysOnPeer ("SPINDLE_Tracing")
