import("amigo_spindle_controller")

var double Ts = 0.001
### Loading Components ###
#Reading Encoders
loadComponent("Spindle_ReadEncoders","SOEM::ReadEncoders")
addPeer("Supervisor","Spindle_ReadEncoders")
Spindle_ReadEncoders.setPeriod(Ts)
Spindle_ReadEncoders.encoderbits = 65536
Spindle_ReadEncoders.enc2SI = array (-4.1666667e-7); # Minus because spindle up is defined positive.
Spindle_ReadEncoders.configure
connect ("Soem.Slave_1006.Slave_1006_value","Spindle_ReadEncoders.enc1_in", ConnPolicy() )

#Publish component
#loadComponent("SpindlePositionToROS","ROS::DoublesToROS")
#addPeer("Supervisor","SpindlePositionToROS")
#setActivity("SpindlePositionToROS",0.01,LowestPriority,ORO_SCHED_OTHER)
#SpindlePositionToROS.NumberOfDoublesInVector = 1
#SpindlePositionToROS.configure
#connect ("Spindle_ReadEncoders.out","SpindlePositionToROS.in", ConnPolicy() )
#stream("SpindlePositionToROS.out1", ros.topic("/spindle_position"))

# Publish JointState Component
loadComponent("SpindleWriteJointStates","ROS::DoublesToJointState")
addPeer("Supervisor","SpindleWriteJointStates")
setActivity("SpindleWriteJointStates",0.01,HighestPriority,ORO_SCHED_RT)
SpindleWriteJointStates.JointNames = strings ( "torso_joint" )
SpindleWriteJointStates.configure
connect( "Spindle_ReadEncoders.out", "SpindleWriteJointStates.pos_in", ConnPolicy() )
stream( "SpindleWriteJointStates.out", ros.topic("/amigo/torso/measurements"))
stream( "SpindleWriteJointStates.out", ros.topic("/amigo/joint_states"))

# Select either the old (for amigo_msgs) and new (for jointstate messages) interface
#Reading spindle setpoints (old)
#loadComponent("Spindle_ReadReferences","SPINDLE::ReadSpindleSetpoint")
#Reading spindle setpoints (new)
loadComponent("Spindle_ReadReferences","SPINDLE::ReadSpindleSetpointJointState")
addPeer("Supervisor","Spindle_ReadReferences")
Spindle_ReadReferences.min_pos = 0.075
Spindle_ReadReferences.max_pos = 0.4
Spindle_ReadReferences.max_vel = 0.07
Spindle_ReadReferences.configure
stream("Spindle_ReadReferences.spindle_setpoint", ros.topic("/amigo/torso/references"));

### Read reference joint angles using Jointstate messages###
# Won't work in the current structure #
#loadComponent("SpindleReadReferenceJointStates","ROS::JointStateToDoubles")
#setActivity("SpindleReadReferenceJointStates",0.0,HighestPriority,ORO_SCHED_RT)
#SpindleReadReferenceJointStates.NumberOfJoints = 1
#SpindleReadReferenceJointStates.configure

#Loading Reference Generator
loadComponent("SpindleReferenceGenerator","ReferenceGenerator")
addPeer("Supervisor","SpindleReferenceGenerator")
SpindleReferenceGenerator.setPeriod(Ts)
SpindleReferenceGenerator.NrInterpolators = 1
SpindleReferenceGenerator.InterpolatorDt = Ts
SpindleReferenceGenerator.InterpolatorEps = 1.0
SpindleReferenceGenerator.configure
SpindleReferenceGenerator.interpolator1 = array (0.0, 0.07, 0.03); #Velocity is carefully tuned. Do not increase because integrator will fill!
connect ("Spindle_ReadReferences.out","SpindleReferenceGenerator.refin", ConnPolicy() )
connect ("Spindle_ReadEncoders.out","SpindleReferenceGenerator.actual_pos", ConnPolicy() )

#Loading Homing component
loadComponent("Spindle_Homing","SpindleHoming")
connectPeers("Supervisor","Spindle_Homing")
connectPeers("Spindle_Homing","Supervisor")
connectPeers("Spindle_Homing","Spindle_ReadEncoders")
addPeer("Spindle_Homing","SpindleReferenceGenerator")
addPeer("Spindle_Homing","Spindle_ReadReferences")
Spindle_Homing.home_vel = 0.01
Spindle_Homing.home_acc = 0.1; #Fast acc means constant velocity means better reproducing homing
Spindle_Homing.stroke  = 0.41
Spindle_Homing.endpos = 0.35
Spindle_Homing.homed = 0; # =False
Spindle_Homing.configure
connect ("DigitalIns2.out2", "Spindle_Homing.endswitch", ConnPolicy() )
connect ("Spindle_Homing.ref_out","SpindleReferenceGenerator.refin", ConnPolicy() )

#Loading Homing component
#loadComponent("Spindle_Homing","AMIGO::Homing")
#connectPeers("Supervisor","Spindle_Homing")
#connectPeers("Spindle_Homing","Supervisor")
#connectPeers("Spindle_Homing","Spindle_ReadEncoders")
#addPeer("Spindle_Homing","SpindleReferenceGenerator")
#addPeer("Spindle_Homing","Spindle_ReadReferences")
#Spindle_Homing.homing_body   		= "Spindle" 			;# name of the body that is stopped/started during homing procedure
#Spindle_Homing.require_homing   	= true		 			;# require homing
#Spindle_Homing.homing_type			= array (3.0)			;# 0 = abs sen homing 1 = servo error homing  2 = Force sen homing  3 = endSwitch homing
#Spindle_Homing.homing_order			= array (1.0)			;# Order in which the joints are homed providing (2.0 3.0 1.0) will home joint two, then joint three and at last joint one
#Spindle_Homing.homing_refPos		= array (1.0)   		;# Pos Reference for the homing joint
#Spindle_Homing.homing_refVel		= array (0.01)  		;# Vel Reference for the homing joint
#Spindle_Homing.homing_stroke		= array (0.41)			;# Stroke from zero point to homing point (encoders are resetted using this value)
#Spindle_Homing.homing_midpos		= array (0.35)  		;# position that the body should have during homing. To avoid collisions with other bodies/ itself
#Spindle_Homing.homing_endpos		= array (0.35)			;# position that the body should go to after homing is finished. (could be same as midpos)
#connect ("DigitalIns2.out2", "Spindle_Homing.endswitch", ConnPolicy() )
#connect ("Spindle_ReadEncoders.out", "Spindle_Homing.relPos_in", ConnPolicy() )
#connect ("Spindle_Homing.ref_out","SpindleReferenceGenerator.refin", ConnPolicy() )
#Spindle_Homing.configure

#Calculating Errors
loadComponent("SpindleCalculateError","MATH::Subtraction")
addPeer("Supervisor","SpindleCalculateError")
SpindleCalculateError.vectorsize = 1
SpindleCalculateError.configure
connect ("SpindleReferenceGenerator.posout","SpindleCalculateError.in_plus", ConnPolicy() )
connect ("Spindle_ReadEncoders.out","SpindleCalculateError.in_minus", ConnPolicy() )

#Loading controller components
#Gain
loadComponent("SpindleGain","MATH::Gain")
addPeer("Supervisor","SpindleGain")
SpindleGain.vectorsize = 1
SpindleGain.gain = -40; ###TODO: Move negative sign to AnalogOuts
SpindleGain.configure
connect ("SpindleCalculateError.out","SpindleGain.in", ConnPolicy() )

#Integrator
loadComponent("SpindleIntegrator","FILTERS::WeakIntegrators")
addPeer("Supervisor","SpindleIntegrator")
SpindleIntegrator.zero_frequency = array ( 0.3 )
SpindleIntegrator.vector_size = 1
SpindleIntegrator.sampling_time = Ts
SpindleIntegrator.configure
connect ("SpindleGain.out","SpindleIntegrator.in", ConnPolicy() )

#LeadLag
loadComponent("SpindleLeadLag","FILTERS::LeadLag")
addPeer("Supervisor","SpindleLeadLag")
SpindleLeadLag.vector_size = 1
SpindleLeadLag.sampling_time = Ts
SpindleLeadLag.zero_frequency = array (1.6)
SpindleLeadLag.pole_frequency = array (60.0)
SpindleLeadLag.configure
connect ("SpindleIntegrator.out","SpindleLeadLag.in", ConnPolicy() )

#LowPass
loadComponent("SpindleSecondOrderLowPass","FILTERS::SecondOrderLowPass")
addPeer("Supervisor","SpindleSecondOrderLowPass")
SpindleSecondOrderLowPass.vector_size = 1
SpindleSecondOrderLowPass.sampling_time = Ts
SpindleSecondOrderLowPass.pole_frequency = array (20.0)
SpindleSecondOrderLowPass.pole_damping = array (0.7)
SpindleSecondOrderLowPass.configure
connect ("SpindleLeadLag.out","SpindleSecondOrderLowPass.in", ConnPolicy() )

#Calculating Feed Forward
loadComponent("SpindleCalculateFFW","CalculateFFW")
addPeer("Supervisor","SpindleCalculateFFW")
SpindleCalculateFFW.FFWgrav = 0.07
SpindleCalculateFFW.FFWstat = 0.05
SpindleCalculateFFW.FFWdyn = 0.4
SpindleCalculateFFW.FFWacc = 0.3
SpindleCalculateFFW.configure
connect ("SpindleReferenceGenerator.velout","SpindleCalculateFFW.ref_vel", ConnPolicy() )
connect ("SpindleReferenceGenerator.accout","SpindleCalculateFFW.ref_acc", ConnPolicy() )

#Calculating Output to encoders
loadComponent("SpindleAddFeedForward","MATH::Addition")
addPeer("Supervisor","SpindleAddFeedForward")
SpindleAddFeedForward.vectorsize = 1
SpindleAddFeedForward.configure
connect ("SpindleCalculateFFW.FFW_out","SpindleAddFeedForward.in1", ConnPolicy() )
connect ("SpindleSecondOrderLowPass.out","SpindleAddFeedForward.in2_event", ConnPolicy() )
connect ("SpindleAddFeedForward.out","AnalogOuts.spindle", ConnPolicy() )

#TODO: Should be passive, only acting on actual errors
#Loading Safety component
loadComponent("SpindleSafety","SpindleSafety")
addPeer("Supervisor","SpindleSafety")
SpindleSafety.error_margin = 0.05
SpindleSafety.configure
# Brake and amplifier should be switched simultaneously: it is undesired to either power the motor with the brake on or to have no power with the brake off
connect ("SpindleSafety.spindle_brake","DigitalOuts.in3", ConnPolicy() );   # Spindle brake
connect ("SpindleSafety.spindle_brake","DigitalOuts2.in1", ConnPolicy() );	# Spindle amplifier
connect ("SpindleCalculateError.out","SpindleSafety.error_pos", ConnPolicy() )

#### LOAD COMPONENT TO PUBLISH STATUS ###
loadComponent("SpindleStatus","ROS::BoolToROS")
addPeer("Supervisor","SpindleStatus")
SpindleStatus.NumberOfBoolPorts = 1
SpindleStatus.configure
SpindleStatus.setPeriod(1)
connect ("SpindleSafety.spindle_brake", "SpindleStatus.bool_in1", ConnPolicy() )
stream("SpindleStatus.bool_out1", ros.topic("/spindle_status"));

#### LOAD COMPONENT TO PUBLISH DIAGNOSTICS ###
loadComponent("SpindleDiagnostics","ROS::RosDiagnostics")
addPeer("Supervisor","SpindleDiagnostics")
SpindleDiagnostics.statusname = "SpindleController"
SpindleDiagnostics.NumberOfVectorPorts = 4
SpindleDiagnostics.NumberOfBoolPorts = 1
SpindleDiagnostics.configure
setActivity("SpindleDiagnostics",1.0,LowestPriority,ORO_SCHED_OTHER)
SpindleDiagnostics.vecname1 = "Reference"
SpindleDiagnostics.vecname2 = "Error"
SpindleDiagnostics.vecname3 = "Voltage"
SpindleDiagnostics.vecname4 = "ControlEffort"
SpindleDiagnostics.boolname1 = "Safe"
connect ("SpindleReferenceGenerator.posout", "SpindleDiagnostics.vec1", ConnPolicy() )
connect ("SpindleCalculateError.out", "SpindleDiagnostics.vec2", ConnPolicy() )
connect ("SpindleAddFeedForward.out", "SpindleDiagnostics.vec3", ConnPolicy() )
connect ("SpindleSecondOrderLowPass.out", "SpindleDiagnostics.vec4", ConnPolicy() )
connect ("SpindleSafety.safety", "SpindleDiagnostics.bool1", ConnPolicy() )
stream("SpindleDiagnostics.diagnostics", ros.topic("/diagnostics"));

#### START COMPONENTS ####
Supervisor.AddAllwaysOnPeer ("Spindle_ReadEncoders")
#Supervisor.AddAllwaysOnPeer ("SpindlePositionToROS")
Supervisor.AddAllwaysOnPeer ("SpindleWriteJointStates")
Supervisor.AddAllwaysOnPeer ("SpindleDiagnostics")
Supervisor.AddAllwaysOnPeer ("SpindleStatus")

Supervisor.NameBodyPart( 2, "spindle")
stream( "Supervisor.spindle_fireup", ros.topic("/spindle_fireup") )
stream( "Supervisor.spindle_enabled", ros.topic("/spindle_enabled") );
Supervisor.AddPeerToBodyPart ("Spindle_ReadReferences",2 )
Supervisor.AddPeerToBodyPart ("SpindleReferenceGenerator",2 )
Supervisor.AddPeerToBodyPart ("SpindleCalculateError",2 )
Supervisor.AddPeerToBodyPart ("SpindleGain",2 )
Supervisor.AddPeerToBodyPart ("SpindleIntegrator",2 )
Supervisor.AddPeerToBodyPart ("SpindleLeadLag",2 )
Supervisor.AddPeerToBodyPart ("SpindleSecondOrderLowPass",2 )
Supervisor.AddPeerToBodyPart ("SpindleCalculateFFW",2 )
Supervisor.AddPeerToBodyPart ("SpindleAddFeedForward",2 )
Supervisor.AddPeerToBodyPart ("SpindleSafety",2 )

Supervisor.AddAllwaysOnPeer ("Spindle_Homing"); #Homing stops itself after finishing, last component because all others have to be started in order to be stopped ;)
