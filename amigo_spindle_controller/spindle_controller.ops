import("amigo_spindle_controller")

var double Ts = 0.001
### Loading Components ###
#Reading Encoders
loadComponent("SpindleReadEncoder","SOEM::ReadEncoders")
addPeer("Supervisor","SpindleReadEncoder")
SpindleReadEncoder.setPeriod(Ts)
SpindleReadEncoder.encoderbits = 65536
SpindleReadEncoder.enc2SI = array (-4.1666667e-7); # Minus because spindle up is defined positive.
SpindleReadEncoder.configure
connect ("Soem.Slave_1006.Slave_1006_value","SpindleReadEncoder.enc1_in", ConnPolicy() )

#Publish component
loadComponent("SpindlePositionToROS","ROS::DoublesToROS")
addPeer("Supervisor","SpindlePositionToROS")
setActivity("SpindlePositionToROS",0.01,LowestPriority,ORO_SCHED_OTHER)
SpindlePositionToROS.NumberOfDoublesInVector = 1
SpindlePositionToROS.configure
connect ("SpindleReadEncoder.out","SpindlePositionToROS.in", ConnPolicy() )
stream("SpindlePositionToROS.out1", ros.topic("/spindle_position"))

# Publish JointState Component
loadComponent("SpindleWriteJointStates","ROS::DoublesToJointState")
addPeer("Supervisor","SpindleWriteJointStates")
setActivity("SpindleWriteJointStates",0.01,HighestPriority,ORO_SCHED_RT)
SpindleWriteJointStates.JointNames = strings ( "spindle_joint" )
SpindleWriteJointStates.configure
connect( "SpindleReadEncoder.out", "SpindleWriteJointStates.pos_in", ConnPolicy() )
#stream( "SpindleWriteJointStates.out", ros.topic("/spindle_controller/measurements"))

# Select either the old (for amigo_msgs) and new (for jointstate messages) interface
#Reading spindle setpoints (old)
loadComponent("SpindleReadSetpoint","SPINDLE::ReadSpindleSetpoint")
#Reading spindle setpoints (new)
#loadComponent("SpindleReadSetpoint","SPINDLE::ReadSpindleSetpointJointState")
addPeer("Supervisor","SpindleReadSetpoint")
SpindleReadSetpoint.min_pos = 0.075
SpindleReadSetpoint.max_pos = 0.4
SpindleReadSetpoint.max_vel = 0.07
SpindleReadSetpoint.configure
stream("SpindleReadSetpoint.spindle_setpoint", ros.topic("/spindle_controller/spindle_coordinates"));

### Read reference joint angles using Jointstate messages###
# Won't work in the current structure #
#loadComponent("SpindleReadReferenceJointStates","ROS::JointStateToDoubles")
#setActivity("SpindleReadReferenceJointStates",0.0,HighestPriority,ORO_SCHED_RT)
#SpindleReadReferenceJointStates.NumberOfJoints = 1
#SpindleReadReferenceJointStates.configure

#Loading Reference Generator
loadComponent("SpindleReferenceGenerator","ReferenceGenerator")
addPeer("Supervisor","SpindleReferenceGenerator")
SpindleReferenceGenerator.setPeriod(Ts)
SpindleReferenceGenerator.NrInterpolators = 1
SpindleReferenceGenerator.InterpolatorDt = Ts
SpindleReferenceGenerator.InterpolatorEps = 1.0
SpindleReferenceGenerator.configure
SpindleReferenceGenerator.interpolator1 = array (0.0, 0.07, 0.03); #Velocity is carefully tuned. Do not increase because integrator will fill!
connect ("SpindleReadSetpoint.out","SpindleReferenceGenerator.refin", ConnPolicy() )
connect ("SpindleReadEncoder.out","SpindleReferenceGenerator.actual_pos", ConnPolicy() )

#Loading Homing component
#loadComponent("SpindleHoming","SpindleHoming")
#connectPeers("Supervisor","SpindleHoming")
#connectPeers("SpindleHoming","Supervisor")
#connectPeers("SpindleHoming","SpindleReadEncoder")
#addPeer("SpindleHoming","SpindleReferenceGenerator")
#addPeer("SpindleHoming","SpindleReadSetpoint")
#SpindleHoming.home_vel = 0.01
#SpindleHoming.home_acc = 0.1; #Fast acc means constant velocity means better reproducing homing
#SpindleHoming.stroke  = 0.41
#SpindleHoming.endpos = 0.35
#SpindleHoming.homed = 0; # =False
#SpindleHoming.configure
#connect ("DigitalIns2.out2", "SpindleHoming.endswitch", ConnPolicy() )
#connect ("SpindleHoming.ref_out","SpindleReferenceGenerator.refin", ConnPolicy() )

#Loading Homing component
loadComponent("SpindleHoming","Homing")
connectPeers("Supervisor","SpindleHoming")
connectPeers("SpindleHoming","Supervisor")
connectPeers("SpindleHoming","SpindleReadEncoder")
addPeer("SpindleHoming","SpindleReferenceGenerator")
addPeer("SpindleHoming","SpindleReadSetpoint")
SpindleHoming.homing_body   	= "spindle" 			;# name of the body that is stopped/started during homing procedure
SpindleHoming.require_homing   	= true		 			;# require homing
SpindleHoming.homing_type		= array (3.0)			;# 0 = abs sen homing 1 = servo error homing  2 = Force sen homing  3 = endSwitch homing
SpindleHoming.homing_order		= array (1.0)				;# Order in which the joints are homed providing (2.0 3.0 1.0) will home joint two, then joint three and at last joint one
SpindleHoming.homing_refPos		= array (1.0)   		;# Pos Reference for the homing joint
SpindleHoming.homing_refVel		= array (0.01)  		;# Vel Reference for the homing joint
SpindleHoming.homing_stroke		= array (0.41)			;# Stroke from zero point to homing point (encoders are resetted using this value)
SpindleHoming.homing_midpos		= array (0.35)  		;# position that the body should have during homing. To avoid collisions with other bodies/ itself
SpindleHoming.homing_endpos		= array (0.35)			;# position that the body should go to after homing is finished. (could be same as midpos)
SpindleHoming.homing_absPos    	= array (0.0)		 	;# homing criterion for abs sen homing			UNUSED FOR SPINDLE HOMING
SpindleHoming.homing_force     	= array (0.0) 			;# homing criterion for Force sen homing		UNUSED FOR SPINDLE HOMING
SpindleHoming.homing_error     	= array (0.0) 			;# homing criterion for servo error homing		UNUSED FOR SPINDLE HOMING
connect ("DigitalIns2.out2", "SpindleHoming.endswitch", ConnPolicy() )
connect ("SpindleReadEncoder.out", "SpindleHoming.relPos_in", ConnPolicy() )
connect ("SpindleHoming.ref_out","SpindleReferenceGenerator.refin", ConnPolicy() )
SpindleHoming.configure

#Calculating Errors
loadComponent("SpindleCalculateError","MATH::Subtraction")
addPeer("Supervisor","SpindleCalculateError")
SpindleCalculateError.vectorsize = 1
SpindleCalculateError.configure
connect ("SpindleReferenceGenerator.posout","SpindleCalculateError.in_plus", ConnPolicy() )
connect ("SpindleReadEncoder.out","SpindleCalculateError.in_minus", ConnPolicy() )

#Loading controller components
#Gain
loadComponent("SpindleGain","MATH::Gain")
addPeer("Supervisor","SpindleGain")
SpindleGain.vectorsize = 1
SpindleGain.gain = -40; ###TODO: Move negative sign to AnalogOuts
SpindleGain.configure
connect ("SpindleCalculateError.out","SpindleGain.in", ConnPolicy() )

#Integrator
loadComponent("SpindleIntegrator","FILTERS::WeakIntegrators")
addPeer("Supervisor","SpindleIntegrator")
SpindleIntegrator.zero_frequency = array ( 0.3 )
SpindleIntegrator.vector_size = 1
SpindleIntegrator.sampling_time = Ts
SpindleIntegrator.configure
connect ("SpindleGain.out","SpindleIntegrator.in", ConnPolicy() )

#LeadLag
loadComponent("SpindleLeadLag","FILTERS::LeadLag")
addPeer("Supervisor","SpindleLeadLag")
SpindleLeadLag.vector_size = 1
SpindleLeadLag.sampling_time = Ts
SpindleLeadLag.zero_frequency = array (1.6)
SpindleLeadLag.pole_frequency = array (60.0)
SpindleLeadLag.configure
connect ("SpindleIntegrator.out","SpindleLeadLag.in", ConnPolicy() )

#LowPass
loadComponent("SpindleSecondOrderLowPass","FILTERS::SecondOrderLowPass")
addPeer("Supervisor","SpindleSecondOrderLowPass")
SpindleSecondOrderLowPass.vector_size = 1
SpindleSecondOrderLowPass.sampling_time = Ts
SpindleSecondOrderLowPass.pole_frequency = array (20.0)
SpindleSecondOrderLowPass.pole_damping = array (0.7)
SpindleSecondOrderLowPass.configure
connect ("SpindleLeadLag.out","SpindleSecondOrderLowPass.in", ConnPolicy() )

#Calculating Feed Forward
loadComponent("SpindleCalculateFFW","CalculateFFW")
addPeer("Supervisor","SpindleCalculateFFW")
SpindleCalculateFFW.FFWgrav = 0.07
SpindleCalculateFFW.FFWstat = 0.05
SpindleCalculateFFW.FFWdyn = 0.4
SpindleCalculateFFW.FFWacc = 0.3
SpindleCalculateFFW.configure
connect ("SpindleReferenceGenerator.velout","SpindleCalculateFFW.ref_vel", ConnPolicy() )
connect ("SpindleReferenceGenerator.accout","SpindleCalculateFFW.ref_acc", ConnPolicy() )

#Calculating Output to encoders
loadComponent("SpindleAddFeedForward","MATH::Addition")
addPeer("Supervisor","SpindleAddFeedForward")
SpindleAddFeedForward.vectorsize = 1
SpindleAddFeedForward.configure
connect ("SpindleCalculateFFW.FFW_out","SpindleAddFeedForward.in1", ConnPolicy() )
connect ("SpindleSecondOrderLowPass.out","SpindleAddFeedForward.in2_event", ConnPolicy() )
connect ("SpindleAddFeedForward.out","AnalogOuts.spindle", ConnPolicy() )

#TODO: Should be passive, only acting on actual errors
#Loading Safety component
loadComponent("SpindleSafety","SpindleSafety")
addPeer("Supervisor","SpindleSafety")
SpindleSafety.error_margin = 0.05
SpindleSafety.configure
connect ("SpindleSafety.spindle_brake","DigitalOuts.spindlebrake", ConnPolicy() )
connect ("SpindleCalculateError.out","SpindleSafety.error_pos", ConnPolicy() )

#### LOAD COMPONENT TO PUBLISH STATUS ###
loadComponent("SpindleStatus","ROS::BoolToROS")
addPeer("Supervisor","SpindleStatus")
SpindleStatus.NumberOfBoolPorts = 1
SpindleStatus.configure
SpindleStatus.setPeriod(1)
connect ("SpindleSafety.spindle_brake", "SpindleStatus.bool_in1", ConnPolicy() )
stream("SpindleStatus.bool_out1", ros.topic("/spindle_status"));

#### LOAD COMPONENT TO PUBLISH DIAGNOSTICS ###
loadComponent("SpindleDiagnostics","ROS::RosDiagnostics")
addPeer("Supervisor","SpindleDiagnostics")
SpindleDiagnostics.statusname = "SpindleController"
SpindleDiagnostics.NumberOfVectorPorts = 4
SpindleDiagnostics.NumberOfBoolPorts = 1
SpindleDiagnostics.configure
setActivity("SpindleDiagnostics",1.0,LowestPriority,ORO_SCHED_OTHER)
SpindleDiagnostics.vecname1 = "Reference"
SpindleDiagnostics.vecname2 = "Error"
SpindleDiagnostics.vecname3 = "Voltage"
SpindleDiagnostics.vecname4 = "ControlEffort"
SpindleDiagnostics.boolname1 = "Safe"
connect ("SpindleReferenceGenerator.posout", "SpindleDiagnostics.vec1", ConnPolicy() )
connect ("SpindleCalculateError.out", "SpindleDiagnostics.vec2", ConnPolicy() )
connect ("SpindleAddFeedForward.out", "SpindleDiagnostics.vec3", ConnPolicy() )
connect ("SpindleSecondOrderLowPass.out", "SpindleDiagnostics.vec4", ConnPolicy() )
connect ("SpindleSafety.safety", "SpindleDiagnostics.bool1", ConnPolicy() )
stream("SpindleDiagnostics.diagnostics", ros.topic("/diagnostics"));

#### START COMPONENTS ####
Supervisor.AddAllwaysOnPeer ("SpindleReadEncoder")
Supervisor.AddAllwaysOnPeer ("SpindlePositionToROS")
Supervisor.AddAllwaysOnPeer ("SpindleWriteJointStates")
Supervisor.AddAllwaysOnPeer ("SpindleDiagnostics")
Supervisor.AddAllwaysOnPeer ("SpindleStatus")

Supervisor.NameBodyPart( 2, "spindle")
stream( "Supervisor.spindle_fireup", ros.topic("/spindle_fireup") )
stream( "Supervisor.spindle_enabled", ros.topic("/spindle_enabled") );
Supervisor.AddPeerToBodyPart ("SpindleReadSetpoint",2 )
Supervisor.AddPeerToBodyPart ("SpindleReferenceGenerator",2 )
Supervisor.AddPeerToBodyPart ("SpindleCalculateError",2 )
Supervisor.AddPeerToBodyPart ("SpindleGain",2 )
Supervisor.AddPeerToBodyPart ("SpindleIntegrator",2 )
Supervisor.AddPeerToBodyPart ("SpindleLeadLag",2 )
Supervisor.AddPeerToBodyPart ("SpindleSecondOrderLowPass",2 )
Supervisor.AddPeerToBodyPart ("SpindleCalculateFFW",2 )
Supervisor.AddPeerToBodyPart ("SpindleAddFeedForward",2 )
Supervisor.AddPeerToBodyPart ("SpindleSafety",2 )

Supervisor.AddAllwaysOnPeer ("SpindleHoming"); #Homing stops itself after finishing, last component because all others have to be started in order to be stopped ;)
