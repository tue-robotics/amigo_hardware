import("philips_arm_controller_dev")
trigger
runScript ("communication_right.ops")
trigger
communication_right.start
trigger

const double sampling_period = 0.004;

### Joint trajectory generator ###
loadComponent("TrajectoryGenerator","TrajectoryGenerator")
TrajectoryGenerator.setPeriod(sampling_period)
TrajectoryGenerator.vector_size	= 8
TrajectoryGenerator.rampDelay	= 3.0
TrajectoryGenerator.frequency 	= array (0.2, 0.0, 0.0)
TrajectoryGenerator.phase 		= array (0.0, 0.0, 0.0)
TrajectoryGenerator.offset 		= array (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
TrajectoryGenerator.gain 		= array (0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.0, 0.0)
#TrajectoryGenerator.offset 		= array (-0.8, 0.0, 0.0, 1.571, 0.0, 0.0, 0.0, 0.0)
#TrajectoryGenerator.gain 		= array (0.3, 0.4, 0.4, 0.3, 0.3, 0.4, 0.4, 3.0)

TrajectoryGenerator.configure

### Decouple motor angles to joint angles (includes encoder conversion factors!!!) ###
loadComponent("MotorToJointAngles","MatrixTransform")
MotorToJointAngles.Nrows = 8
MotorToJointAngles.Ncolumns = 8
MotorToJointAngles.configure
MotorToJointAngles.function1 = array ( 0.00032, -0.000323, 	0.0, 		0.0, 		0.0, 		0.0, 		0.0, 		0.0		)
MotorToJointAngles.function2 = array (-0.00032, -0.000323, 	0.0, 		0.0, 		0.0, 		0.0, 		0.0, 		0.0		)
MotorToJointAngles.function3 = array ( 0.0,      0.0, 		0.0, 		0.0, 		0.0, 		0.0, 		0.00095, 	0.0		)
MotorToJointAngles.function4 = array ( 0.0,      0.0, 		0.0002197, 	0.0002197, 	0.0, 		0.0, 		0.0, 		0.0		)
MotorToJointAngles.function5 = array ( 0.0,      0.0, 	   -0.0002197, 	0.0002197, 	0.0, 		0.0, 		0.0, 		0.0		)
MotorToJointAngles.function6 = array ( 0.0,      0.0, 		0.0, 		0.0,		0.00121, 	0.00121, 	0.0, 		0.0		)
MotorToJointAngles.function7 = array ( 0.0,      0.0, 		0.0, 		0.0, 		0.00121,   -0.00121, 	0.0, 		0.0		)
MotorToJointAngles.function8 = array ( 0.0,      0.0, 		0.0, 		0.0, 		0.0, 		0.0, 		0.0, 		0.03	)

### Convert degrees to radians
loadComponent("DegToRad","MATH::Gain")
DegToRad.vectorsize = 8
DegToRad.gain = 0.0174532925
DegToRad.configure

### Get the real-time velocity and acceleration
loadComponent("RealTimeDerivator","AMIGO::RealTimeDerivator")
RealTimeDerivator.bw = 10.0
RealTimeDerivator.vector_size = 8
RealTimeDerivator.setPeriod(sampling_period)
RealTimeDerivator.configure

### PERA USB IO ###
loadComponent("PERA_IO","PERA::PERA_USB_IO")
PERA_IO.setPeriod(sampling_period)
PERA_IO.absSenJumpPosProperty = array (1024.0, 732.0, 721.0, 1024.0, 706.0, 1024.0, 1024.0)
PERA_IO.afterAbsSenJumpProperty = array (0.0, 100.0, 250.0, 0.0, 100.0, 0.0, 0.0)
PERA_IO.configure

### Convert measured voltages from the torque sensors to the joint torque measurements ###
loadComponent("SensorTorques","SensorTorques")
SensorTorques.Ksensor = array (0.0025, 0.0025, 0.0025, 0.0025, 0.0025, 0.0025, 0.0025, 0.0025)
SensorTorques.Voffset = array (0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2)
SensorTorques.Xoffset = array (0.001812, 0.002061, 0.001379, 0.001345, 0.002259, 0.002763, 0.004158, 0.003472)
SensorTorques.Stiffness = array (777777.7, 777777.7, 2008415.0, 3142873.0, 700.0, 12935.0, 36744.86, 48136.76)
#SensorTorques.Stiffness = array (1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0)
SensorTorques.PivotDistance = array (0.03, 0.03, 0.025, 0.025, 1.0, 1.0, 0.017, 0.017)
#SensorTorques.PivotDistance = array (1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0)
SensorTorques.setPeriod(sampling_period)
SensorTorques.configure

### Adaptive joint torque sensory feedback controller ###
loadComponent("PERA_JTF","PERA::PERA_JTF_control")
#JOINTS								SH1		SH2		SH3		EL1		EL2		WR1		WR2		H
PERA_JTF.motor_constants 	= array (0.0,	0.0, 	0.0,	0.0,	0.0,	1000.0,	0.0,	0.0)
PERA_JTF.joint_inertia 		= array (0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0)
PERA_JTF.coulomb_friction 	= array (0.0,	0.0,	0.0, 	0.0,	0.0,	1.0,	0.0,	1.0)
PERA_JTF.viscous_friction 	= array (0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0)
PERA_JTF.torque_gain 		= array (0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0)
PERA_JTF.torque_offset 		= array (0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0)
PERA_JTF.Lambda_gain 		= array (40.0,	40.0,	30.0,	50.0,	20.0,	10.0,	50.0,	20.0)
PERA_JTF.L_gain 			= array (3.0,	3.0,	3.0,	3.0,	2.0,	1.0,	1.0,	1.0)
#PERA_JTF.Gamma_gain 		= array (0.5,	0.5,	0.5,	0.5,	0.5,	1.0,	1.0,	1.0,	0.5,	0.5,	0.5,	0.5,	0.5,	1.0,	1.0,	1.0,	0.5,	0.5,	0.5,	0.5,	0.5,	1.0,	1.0,	1.0,	0.5,	0.5,	0.5,	0.5,	0.5,	1.0,	1.0,	1.0,	0.5,	0.5,	0.5,	0.5,	0.5,	1.0,	1.0,	1.0)
PERA_JTF.Gamma_gain 		= array (0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.5,	0.5,	1.0,	0.2,	0.2,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0,	0.0)
#									 00000000000000000000000000000000000	111111111111111111111111111111111111	222222222222222222222222222222222222	333333333333333333333333333333333333	444444444444444444444444444444444444	555555555555555555555555555555555555	666666666666666666666666666666666666	77777777777777777777777777777777777	
PERA_JTF.setPeriod(sampling_period)
PERA_JTF.configure

### Decouple joint torques to motor torques ###
loadComponent("JointToMotorTorques","MatrixTransform")
JointToMotorTorques.Nrows = 8
JointToMotorTorques.Ncolumns = 8
JointToMotorTorques.configure
JointToMotorTorques.function1 = array (0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
JointToMotorTorques.function2 = array (-0.5, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
JointToMotorTorques.function3 = array (0.0, 0.0, 0.0, 0.5, -0.5, 0.0, 0.0, 0.0)
JointToMotorTorques.function4 = array (0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0)
JointToMotorTorques.function5 = array (0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0)
JointToMotorTorques.function6 = array (0.0, 0.0, 0.0, 0.0, 0.0, 0.5, -0.5, 0.0)
JointToMotorTorques.function7 = array (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0)
JointToMotorTorques.function8 = array (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)

### Saturation on the controller output
loadComponent("OutputLimiter","DISCONTINUITIES::Saturation")
OutputLimiter.upper_limit = array ( 25000.0, 25000.0, 20000.0, 20000.0, 15000.0, 15000.0, 25000.0, 25000.0 )
OutputLimiter.lower_limit = array (-25000.0,-25000.0,-20000.0,-20000.0,-15000.0,-15000.0,-25000.0,-25000.0 )
OutputLimiter.vector_size = 8
OutputLimiter.configure

### Get the real-time velocity and acceleration
loadComponent("WriteArmDataMsg","AMIGO::WriteArmDataMsg")
WriteArmDataMsg.totalJoints = 8
WriteArmDataMsg.totalParams = 5
WriteArmDataMsg.selectJoint = 5
WriteArmDataMsg.setPeriod(0.02)
WriteArmDataMsg.configure

###Setting up reporting
loadComponent("Reporter", "OCL::FileReporting")
addPeer("Reporter","TrajectoryGenerator")
Reporter.reportPort("TrajectoryGenerator","pos")
Reporter.reportPort("TrajectoryGenerator","vel")
#Reporter.reportPort("TrajectoryGenerator","acc")
addPeer("Reporter","RealTimeDerivator")
Reporter.reportPort("RealTimeDerivator","ue")
Reporter.reportPort("RealTimeDerivator","ude")
#Reporter.reportPort("RealTimeDerivator","udde")
addPeer("Reporter","SensorTorques")
Reporter.reportPort("SensorTorques","joint_torques_out")
addPeer("Reporter","PERA_JTF")
Reporter.reportPort("PERA_JTF","parameter_vector")
Reporter.reportPort("PERA_JTF","joint_torque_control_output")
addPeer("Reporter","OutputLimiter")
Reporter.reportPort("OutputLimiter","out")
Reporter.ReportFile = "jtf_report_wr1.dat"
Reporter.setPeriod(sampling_period)
Reporter.configure

connect ("PERA_IO.relEnc",								"MotorToJointAngles.in", 				ConnPolicy() )
connect ("PERA_IO.forceSen",							"SensorTorques.voltage_in", 			ConnPolicy() )
connect ("MotorToJointAngles.out",						"DegToRad.in", 							ConnPolicy() )
connect ("DegToRad.out",								"RealTimeDerivator.u",					ConnPolicy() )
connect ("RealTimeDerivator.ue",						"PERA_JTF.joint_position_measured", 	ConnPolicy() )
connect ("RealTimeDerivator.ude",						"PERA_JTF.joint_velocity_measured", 	ConnPolicy() )
connect ("RealTimeDerivator.udde",						"PERA_JTF.joint_acceleration_measured",	ConnPolicy() )
connect ("TrajectoryGenerator.pos",						"PERA_JTF.joint_position_reference",	ConnPolicy() )
connect ("TrajectoryGenerator.vel",						"PERA_JTF.joint_velocity_reference",	ConnPolicy() )
connect ("TrajectoryGenerator.acc",						"PERA_JTF.joint_acceleration_reference",ConnPolicy() )
connect ("SensorTorques.joint_torques_out",				"PERA_JTF.joint_torque_measured", 		ConnPolicy() )
connect ("PERA_JTF.joint_torque_control_output",		"JointToMotorTorques.in", 				ConnPolicy() )
connect ("JointToMotorTorques.out",						"OutputLimiter.in", 					ConnPolicy() )
connect ("OutputLimiter.out",							"PERA_IO.cmdTorqueIn", 					ConnPolicy() )
connect ("TrajectoryGenerator.enablePort",				"PERA_IO.enablePort", 					ConnPolicy() )

connect ("TrajectoryGenerator.pos",						"WriteArmDataMsg.rpos",					ConnPolicy() )
connect ("TrajectoryGenerator.vel",						"WriteArmDataMsg.rvel",					ConnPolicy() )
connect ("TrajectoryGenerator.acc",						"WriteArmDataMsg.racc", 				ConnPolicy() )
connect ("RealTimeDerivator.ue",						"WriteArmDataMsg.mpos",					ConnPolicy() )
connect ("RealTimeDerivator.ude",						"WriteArmDataMsg.mvel",					ConnPolicy() )
connect ("RealTimeDerivator.udde",						"WriteArmDataMsg.macc", 				ConnPolicy() )
connect ("SensorTorques.joint_torques_out",				"WriteArmDataMsg.mtor",					ConnPolicy() )
connect ("PERA_JTF.joint_torque_control_output",		"WriteArmDataMsg.ctrl",					ConnPolicy() )
connect ("PERA_JTF.parameter_vector",					"WriteArmDataMsg.pars",					ConnPolicy() )

#to plot refPos measPos measTor ctrl for selected joint
#rxplot /jointDataRight/data[0],/jointDataRight/data[3] /jointDataRight/data[6] /jointDataRight/data[7]
stream  ("WriteArmDataMsg.jointdata", 	communication_right.jointDataRight)
#stream  ("WriteArmDataMsg.armdata", 	communication_right.armDataRight)

TrajectoryGenerator.start
MotorToJointAngles.start
DegToRad.start
SensorTorques.start
JointToMotorTorques.start
RealTimeDerivator.start
OutputLimiter.start
PERA_JTF.start
PERA_IO.start
WriteArmDataMsg.start
Reporter.start
